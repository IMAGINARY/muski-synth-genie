{"mappings":"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","sources":["src/lib/ts/index.ts","index.ts","src/lib/ts/synth-genie.ts","synth-genie.ts","src/lib/scss/synth-genie.module.scss","src/lib/ts/util.ts","util.ts","src/lib/ts/segments.ts","segments.ts"],"sourcesContent":["import SynthGenie from './synth-genie';\n\nexport * from './synth-genie';\n\nexport default SynthGenie;\n",null,"/* eslint-disable no-console */\nimport { tf, PianoGenie } from '@magenta/music';\nimport * as Tone from 'tone';\nimport { strict as assert } from 'assert';\n\nimport classes from '../scss/synth-genie.module.scss';\nimport { getRelativePointerPosition, getCurvePoints } from './util';\nimport Segments from './segments';\n\ntf.disableDeprecationWarnings();\n\nconst PIANO_GENIE_CHECKPOINT =\n  'https://storage.googleapis.com/magentadata/js/checkpoints/piano_genie/model/epiano/stp_iq_auto_contour_dt_166006';\n\nconst LOWEST_PIANO_KEY_MIDI_NOTE = 21;\nconst NUM_BEATS = 16;\nconst NUM_BUTTONS = 8;\n\nconst exponentialEnvelopeCurve: Tone.EnvelopeCurve = 'exponential';\nconst envelopeOptions = {\n  attack: 0.01,\n  attackCurve: exponentialEnvelopeCurve,\n  decay: 0.01,\n  decayCurve: exponentialEnvelopeCurve,\n  release: 0.5,\n  releaseCurve: exponentialEnvelopeCurve,\n  sustain: 0.9,\n};\nconst SYNTH_OPTIONS: ConstructorParameters<typeof Tone.AMSynth>[0] = {\n  volume: 0,\n  detune: 0,\n  portamento: 0,\n  harmonicity: 2.5,\n  oscillator: {\n    phase: 0,\n    type: 'fatsawtooth',\n    count: 3,\n    spread: 20,\n  },\n  envelope: {\n    attack: 0.1,\n    attackCurve: 'linear',\n    decay: 0.2,\n    decayCurve: 'exponential',\n    release: 0.3,\n    releaseCurve: 'exponential',\n    sustain: 0.2,\n  },\n  modulation: {\n    phase: 0,\n    type: 'square',\n  },\n  modulationEnvelope: {\n    attack: 0.5,\n    attackCurve: 'linear',\n    decay: 0.01,\n    decayCurve: 'exponential',\n    release: 0.5,\n    releaseCurve: 'exponential',\n    sustain: 1,\n  },\n};\n\nfunction computeAllowedPianoKeys(minMidiNote: number, maxMidiNote: number) {\n  assert(minMidiNote < maxMidiNote);\n  const keyMin = Math.max(0, minMidiNote - LOWEST_PIANO_KEY_MIDI_NOTE);\n  const maxKey = Math.min(maxMidiNote - LOWEST_PIANO_KEY_MIDI_NOTE, 88 - 1);\n  const numKeys = Math.max(0, maxKey - keyMin + 1);\n  const keys = new Array(numKeys).fill(0).map((_, i) => keyMin + i);\n  console.log(keys);\n  return keys;\n}\n\nconst TEMPERATURE = 0.25;\n\nconst CANVAS_WIDTH = 512;\nconst CANVAS_HEIGHT = 256;\n\nexport type SynthGenieOptions = Record<string, unknown>;\n\nconst defaultOptions: Readonly<SynthGenieOptions> = {};\n\ntype RenderingContext2D =\n  | CanvasRenderingContext2D\n  | OffscreenCanvasRenderingContext2D;\n\ntype CellData = {\n  cellX: number;\n  cellY: number;\n};\n\nexport default class SynthGenie {\n  protected readonly _options: SynthGenieOptions;\n\n  protected handlers = this.getHandlers();\n\n  protected element: Element;\n\n  protected pane: HTMLDivElement;\n\n  protected pointers: Map<number, CellData>;\n\n  protected canvas: HTMLCanvasElement;\n\n  protected context: RenderingContext2D;\n\n  protected segments: Segments<number>;\n\n  protected numNotes: number;\n\n  protected position: number;\n\n  protected loopCount: number;\n\n  protected genie: PianoGenie;\n\n  protected gain: Tone.Gain;\n\n  protected beatLength: number;\n\n  protected relativeNoteLength: number;\n\n  protected minMidiNote: number;\n\n  protected maxMidiNote: number;\n\n  protected allowedPianoKeys: number[];\n\n  protected resetStateOnLoop: boolean;\n\n  protected sustainInSegments: boolean;\n\n  protected slideInSegments: boolean;\n\n  protected showGrid: boolean;\n\n  protected showBar: boolean;\n\n  protected dotColor: string;\n\n  protected relativeDotSize: number;\n\n  protected lineColor: string;\n\n  protected relativeLineWidth: number;\n\n  protected synthOptions: ConstructorParameters<typeof Tone.AMSynth>[0];\n\n  protected synthPool: Tone.AMSynth[];\n\n  protected synth: Tone.AMSynth | null;\n\n  protected timer: ReturnType<typeof setInterval> | 0;\n\n  protected constructor(\n    element: Element,\n    options: Partial<SynthGenieOptions> = {},\n  ) {\n    console.log('Starting');\n    this._options = { ...defaultOptions, ...options };\n\n    this.numNotes = NUM_BEATS;\n    this.segments = new Segments(this.numNotes, () => -1);\n    this.position = 0;\n    this.loopCount = 0;\n    this.resetStateOnLoop = true;\n    this.sustainInSegments = true;\n    this.slideInSegments = true;\n    this.showGrid = true;\n    this.showBar = true;\n    this.beatLength = 250;\n    this.relativeNoteLength = 1.0;\n    this.minMidiNote = 21;\n    this.maxMidiNote = 21 + 88 - 1;\n    this.dotColor = '#2c2c2c';\n    this.relativeDotSize = 0.0;\n    this.lineColor = '#2c2c2c';\n    this.relativeLineWidth = 0.6;\n    this.allowedPianoKeys = computeAllowedPianoKeys(\n      this.minMidiNote,\n      this.maxMidiNote,\n    );\n    console.log('Starting 2');\n\n    const canvas = document.createElement('canvas');\n    canvas.width = CANVAS_WIDTH;\n    canvas.height = CANVAS_HEIGHT;\n    const context = canvas.getContext('2d');\n    assert(context !== null);\n\n    const pane = document.createElement('div');\n    pane.setAttribute('touch-action', 'none'); // for Pointer Events Polyfill\n    pane.classList.add(classes.pane);\n    pane.addEventListener('pointerdown', this.handlers.addPointer);\n    pane.addEventListener('pointerup', this.handlers.removePointer);\n    pane.addEventListener('pointercancel', this.handlers.removePointer);\n    pane.addEventListener('contextmenu', (event) => event.preventDefault());\n    pane.appendChild(canvas);\n\n    while (element.firstChild) element.firstChild.remove();\n    element.appendChild(pane);\n\n    this.pane = pane;\n    this.element = element;\n    this.canvas = canvas;\n    this.context = context;\n\n    this.pointers = new Map();\n\n    this.genie = new PianoGenie(PIANO_GENIE_CHECKPOINT);\n    this.gain = new Tone.Gain(1).toDestination();\n\n    this.synthOptions = SYNTH_OPTIONS;\n    this.synthPool = [];\n    this.synth = null;\n    this.timer = 0;\n\n    this.updateGrid();\n  }\n\n  static async create(\n    element: Element,\n    options: Partial<SynthGenieOptions> = {},\n  ) {\n    const synthGenie = new SynthGenie(element, options);\n    await synthGenie.init();\n    return synthGenie;\n  }\n\n  play() {\n    if (this.timer === 0) {\n      const { beatLength } = this;\n      this.timer = setTimeout(() => {\n        this.timer = setInterval(() => this.playBeat(), beatLength);\n      }, 0);\n    }\n  }\n\n  pause() {\n    if (this.timer !== 0) {\n      clearTimeout(this.timer);\n      clearInterval(this.timer);\n      this.timer = 0;\n      if (this.synth !== null) {\n        this.releaseAndFreeSynth(this.synth, 0);\n        this.synth = null;\n      }\n    }\n  }\n\n  isPlaying() {\n    return this.timer !== 0;\n  }\n\n  protected playBeat() {\n    const { genie } = this;\n\n    const { segment, indexInSegment } = this.segments.getSegmentOf(\n      this.position,\n    );\n    const cell = segment[indexInSegment];\n    assert(typeof cell !== 'undefined');\n\n    if (this.synth !== null && cell === -1) {\n      // note still ringing, but shouldn't (grid values changed)\n      this.releaseAndFreeSynth(this.synth, 0);\n      this.synth = null;\n    }\n\n    if (cell !== -1) {\n      const frequency = this.getGenieFrequency(cell);\n\n      const attack =\n        this.synth === null || indexInSegment === 0 || !this.sustainInSegments;\n      const release =\n        indexInSegment === segment.length - 1 || !this.sustainInSegments;\n\n      this.synth = this.synth ?? this.synthPool.pop() ?? this.createSynth();\n\n      const noteDuration = (this.beatLength * this.relativeNoteLength) / 1000;\n\n      if (attack || !this.slideInSegments) {\n        // attack\n        this.synth.triggerAttack(frequency);\n      } else {\n        // ramp to next note frequency\n        this.synth.frequency.exponentialRampTo(frequency, noteDuration * 0.1);\n      }\n      if (release) {\n        // release note at the end of this cell\n        this.releaseAndFreeSynth(this.synth, noteDuration);\n        this.synth = null;\n      }\n    }\n\n    this.updateGrid();\n\n    this.position += 1;\n    if (this.position === this.segments.size) {\n      this.position = 0;\n      this.loopCount += 1;\n      if (this.resetStateOnLoop) genie.resetState();\n    }\n  }\n\n  createSynth() {\n    return new Tone.AMSynth(this.synthOptions).connect(this.gain);\n  }\n\n  releaseAndFreeSynth(synth: Tone.AMSynth, seconds: number) {\n    synth.triggerRelease(Tone.now() + seconds);\n    const releaseDuration = Tone.Time(synth.envelope.release).toSeconds();\n    const toneDuration = seconds + releaseDuration;\n    setTimeout(() => this.synthPool.push(synth), toneDuration * 1000);\n  }\n\n  getGenieFrequency(cell: number) {\n    const genieButton = NUM_BUTTONS - 1 - cell;\n    const pianoKey = this.genie.nextFromKeyList(\n      genieButton,\n      this.allowedPianoKeys,\n      TEMPERATURE,\n    );\n    const midiNote = LOWEST_PIANO_KEY_MIDI_NOTE + pianoKey;\n    const frequency = Tone.Frequency(midiNote, 'midi').toFrequency();\n    return frequency;\n  }\n\n  async init() {\n    const { genie } = this;\n    await genie.initialize();\n    console.log('🧞‍♀️ ready!');\n\n    this.play();\n  }\n\n  getOptions() {\n    return { ...this._options };\n  }\n\n  applyOptions(o: Partial<SynthGenieOptions>) {\n    Object.assign(this._options, o);\n  }\n\n  protected getHandlers() {\n    return {\n      addPointer: this.addPointer.bind(this),\n      updatePointer: this.updatePointer.bind(this),\n      removePointer: this.removePointer.bind(this),\n    };\n  }\n\n  getCellCoordinates(relX: number, relY: number) {\n    const cellX = Math.floor(relX * this.numNotes);\n    const cellY = Math.floor(relY * NUM_BUTTONS);\n    return { cellX, cellY };\n  }\n\n  protected addPointer(pe: PointerEvent) {\n    this.removePointer(pe);\n    this.pane.addEventListener('pointermove', this.handlers.updatePointer);\n    this.pane.setPointerCapture(pe.pointerId);\n\n    const { relX, relY } = getRelativePointerPosition(pe, this.pane);\n    const { cellX, cellY } = this.getCellCoordinates(relX, relY);\n    this.pointers.set(pe.pointerId, { cellX, cellY });\n\n    const { segments } = this;\n    segments.isolate(cellX);\n    segments.set(cellX, cellY);\n\n    this.updateGrid();\n  }\n\n  protected updateAllowedPianoKeys() {\n    this.allowedPianoKeys = computeAllowedPianoKeys(\n      this.minMidiNote,\n      this.maxMidiNote,\n    );\n  }\n\n  protected updatePointer(pe: PointerEvent) {\n    if (pe.buttons === 0) return;\n\n    const id = pe.pointerId;\n    const { relX, relY } = getRelativePointerPosition(pe, this.pane);\n    const pointerData = this.pointers.get(id);\n    assert(typeof pointerData !== 'undefined');\n    const { cellX: prevCellX, cellY: prevCellY } = pointerData;\n\n    const { cellX, cellY } = this.getCellCoordinates(relX, relY);\n    this.pointers.set(id, { cellX, cellY });\n\n    const { segments } = this;\n    if (prevCellX === cellX) {\n      // same x cell\n      if (prevCellY !== cellY) {\n        // different y cell\n        if (cellY < 0 || cellY >= NUM_BUTTONS) {\n          // out of y range\n          segments.isolate(cellX);\n          segments.set(cellX, -1);\n        } else {\n          // within y range\n          segments.set(cellX, cellY);\n        }\n        this.updateGrid();\n      }\n    } else {\n      // different x cell (possibly with some columns in between)\n      const [previousSegmentIndex, segmentIndex] = this.connectCells(\n        pointerData,\n        { cellX, cellY },\n      );\n      if (\n        prevCellX !== -1 &&\n        cellX !== -1 &&\n        previousSegmentIndex !== segmentIndex\n      ) {\n        if (prevCellX < cellX) {\n          segments.splitAfter(cellX);\n        } else {\n          segments.splitBefore(cellX);\n        }\n      }\n      this.updateGrid();\n    }\n  }\n\n  protected connectCells(first: CellData, second: CellData): [number, number] {\n    if (second.cellX < first.cellX) {\n      const [secondSegmentIndex, firstSegmentIndex] = this.connectCells(\n        second,\n        first,\n      );\n      return [firstSegmentIndex, secondSegmentIndex];\n    }\n\n    const { cellX: x0, cellY: y0 } = first;\n    const { cellX: x1, cellY: y1 } = second;\n\n    const slope = (y1 - y0) / (x1 - x0);\n\n    const { segments } = this;\n    const [firstSegmentIndex, secondSegmentIndex] = segments.join(x0, x1);\n\n    const clampedX0 = Math.min(segments.size - 1, Math.max(x0, 0));\n    const clampedX1 = Math.min(segments.size - 1, Math.max(x1, 0));\n    for (let x = clampedX0; x <= clampedX1; x += 1) {\n      const y = Math.floor(y0 + slope * (x - x0));\n      if (y < 0 || y >= NUM_BUTTONS) {\n        // make it possible to disable columns by dragging them out of the y range\n        segments.isolate(x);\n        segments.set(x, -1);\n      } else {\n        segments.set(x, y);\n      }\n    }\n\n    return [firstSegmentIndex, secondSegmentIndex];\n  }\n\n  protected removePointer(pe: PointerEvent) {\n    const id = pe.pointerId;\n\n    this.pointers.delete(id);\n\n    if (this.pointers.size === 0)\n      this.pane.removeEventListener('pointermove', this.handlers.updatePointer);\n  }\n\n  protected updateGrid() {\n    this.context.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n    if (this.showBar) {\n      this.paintBar();\n    }\n    if (this.showGrid) {\n      this.paintCells();\n      this.paintGrid();\n    }\n\n    this.paintSegments();\n  }\n\n  protected paintSegments() {\n    const { segments } = this;\n\n    // compute segments\n    const controlPointsPerSegment: { x: number; y: number }[][] = [];\n    const stepX = CANVAS_WIDTH / segments.size;\n    const stepY = CANVAS_HEIGHT / NUM_BUTTONS;\n    let cellX = 0;\n    for (let i = 0; i < segments.numSegments; i += 1) {\n      const segment = segments.getSegment(i);\n      const controlPoints: { x: number; y: number }[] = [];\n      assert(typeof segment !== 'undefined');\n      for (let j = 0; j < segment.length; j += 1) {\n        const cellY = segment[j];\n        if (cellY >= 0) {\n          const x = stepX * (0.5 + cellX);\n          const y = stepY * (0.5 + cellY);\n          controlPoints.push({ x, y });\n        }\n        cellX += 1;\n      }\n      controlPointsPerSegment.push(controlPoints);\n    }\n\n    const minCellDim = Math.min(\n      CANVAS_HEIGHT / NUM_BUTTONS,\n      CANVAS_WIDTH / segments.size,\n    );\n\n    const { context, relativeDotSize, dotColor, relativeLineWidth, lineColor } =\n      this;\n\n    context.save();\n    const dotRadius = minCellDim * relativeDotSize * 0.5;\n    if (dotRadius > 0) {\n      context.fillStyle = dotColor;\n      controlPointsPerSegment.forEach((controlPoints) =>\n        controlPoints.forEach(({ x, y }) => {\n          context.beginPath();\n          context.ellipse(x, y, dotRadius, dotRadius, 0, 0, 2 * Math.PI);\n          context.closePath();\n          context.fill();\n        }),\n      );\n    }\n\n    const lineWidth = minCellDim * relativeLineWidth;\n    if (lineWidth > 0) {\n      context.beginPath();\n      context.strokeStyle = lineColor;\n      context.lineWidth = lineWidth;\n      context.lineCap = 'round';\n      context.lineJoin = 'round';\n      controlPointsPerSegment.forEach((controlPoints) => {\n        if (controlPoints.length === 1) {\n          const [{ x, y }] = controlPoints;\n          context.moveTo(x, y);\n          context.lineTo(x, y);\n        } else if (controlPoints.length === 2) {\n          const [{ x: x0, y: y0 }, { x: x1, y: y1 }] = controlPoints;\n          context.moveTo(x0, y0);\n          context.lineTo(x1, y1);\n        } else if (controlPoints.length >= 3) {\n          const points = getCurvePoints(controlPoints, 0.35);\n          const firstPoint = points.shift();\n          assert(typeof firstPoint !== 'undefined');\n\n          context.moveTo(firstPoint.x, firstPoint.y);\n          points.forEach(({ x, y }) => context.lineTo(x, y));\n        }\n      });\n      context.stroke();\n      context.closePath();\n    }\n    context.restore();\n  }\n\n  protected paintGrid() {\n    const { context, segments } = this;\n\n    context.save();\n    context.beginPath();\n    context.strokeStyle = '#b3b2b2';\n    const stepX = CANVAS_WIDTH / segments.size;\n    for (let i = 1; i < segments.size; i += 1) {\n      const x = stepX * i;\n      context.moveTo(x, 0);\n      context.lineTo(x, CANVAS_HEIGHT);\n    }\n    const stepY = CANVAS_HEIGHT / NUM_BUTTONS;\n    for (let i = 1; i < NUM_BUTTONS; i += 1) {\n      const y = stepY * i;\n      context.moveTo(0, y);\n      context.lineTo(CANVAS_WIDTH, y);\n    }\n    context.stroke();\n    context.closePath();\n    context.restore();\n  }\n\n  protected paintCells() {\n    const { context, segments } = this;\n\n    context.save();\n    context.beginPath();\n    context.fillStyle = '#b3b2b2';\n    const stepX = CANVAS_WIDTH / segments.size;\n    const stepY = CANVAS_HEIGHT / NUM_BUTTONS;\n    let cellX = 0;\n    for (let i = 0; i < this.segments.numSegments; i += 1) {\n      const segment = this.segments.getSegment(i);\n      assert(typeof segment !== 'undefined');\n      for (let j = 0; j < segment.length; j += 1) {\n        const cellY = segment[j];\n        if (cellY >= 0) {\n          const x = stepX * cellX;\n          const y = stepY * cellY;\n          context.rect(x, y, stepX, stepY);\n        }\n        cellX += 1;\n      }\n    }\n    context.fill();\n    context.closePath();\n    context.restore();\n  }\n\n  protected paintBar() {\n    const { context } = this;\n\n    context.save();\n    context.fillStyle = 'rgba(211,211,211,0.4)';\n    const stepX = CANVAS_WIDTH / this.numNotes;\n    const x = stepX * this.position;\n    context.fillRect(x, 0, stepX, CANVAS_WIDTH);\n    context.restore();\n  }\n}\n\nexport { defaultOptions };\n",null,".pane {\n  position: relative;\n  width: 512px;\n  height: 256px;\n  /*\n  width: 100%;\n  height: 100%;\n*/\n  overflow: visible;\n  touch-action: none;\n  box-sizing: border-box;\n}\n\n.pane * {\n  touch-action: none;\n}\n\n.pane > canvas {\n  position: relative;\n  width: 512px;\n  height: 256px;\n  /*  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  width: 100%;\n  height: 100%;\n */\n  border: 1px solid gray;\n}\n","function getRelativePointerPosition(pe: PointerEvent, elem: HTMLElement) {\n  const { left, top, width, height } = elem.getBoundingClientRect();\n  const x = pe.clientX - left;\n  const y = pe.clientY - top;\n  const relX = x / width;\n  const relY = y / height;\n  return { x, y, relX, relY, width, height };\n}\n\nfunction getCurvePoints(\n  points: { x: number; y: number }[],\n  tension = 0.5,\n  isClosed = false,\n  numOfSegments = 16,\n): { x: number; y: number }[] {\n  // convert to internal format\n  const pts = new Array<number>();\n  points.forEach(({ x, y }) => pts.push(x, y));\n\n  // The algorithm require a previous and next point to the actual point array.\n  // Check if we will draw closed or open curve.\n  // If closed, copy end points to beginning and first points to end\n  // If open, duplicate first points to beginning, end points to end\n  const firstPoint = points[0];\n  const lastPoint = points[points.length - 1];\n  if (isClosed) {\n    pts.unshift(lastPoint.x, lastPoint.y);\n    pts.unshift(lastPoint.x, lastPoint.y);\n    pts.push(firstPoint.x, firstPoint.y);\n  } else {\n    pts.unshift(firstPoint.x, firstPoint.y); // copy 1. point and insert at beginning\n    pts.push(lastPoint.x, lastPoint.y); // copy last point and append\n  }\n\n  // ok, lets start..\n  const res = new Array<{ x: number; y: number }>();\n\n  // 1. loop goes through point array\n  // 2. loop goes through each segment between the 2 pts + 1e point before and after\n  for (let i = 2; i < pts.length - 4; i += 2) {\n    for (let t = 0; t <= numOfSegments; t += 1) {\n      // calc tension vectors\n      const t1x = (pts[i + 2] - pts[i - 2]) * tension;\n      const t2x = (pts[i + 4] - pts[i]) * tension;\n\n      const t1y = (pts[i + 3] - pts[i - 1]) * tension;\n      const t2y = (pts[i + 5] - pts[i + 1]) * tension;\n\n      // calc step\n      const st = t / numOfSegments;\n\n      // calc cardinals\n      const c1 = 2 * st ** 3 - 3 * st ** 2 + 1;\n      const c2 = -(2 * st ** 3) + 3 * st ** 2;\n      const c3 = st ** 3 - 2 * st ** 2 + st;\n      const c4 = st ** 3 - st ** 2;\n\n      // calc x and y cords with common control vectors\n      const x = c1 * pts[i] + c2 * pts[i + 2] + c3 * t1x + c4 * t2x;\n      const y = c1 * pts[i + 1] + c2 * pts[i + 3] + c3 * t1y + c4 * t2y;\n\n      // store points in array\n      res.push({ x, y });\n    }\n  }\n\n  return res;\n}\n\nexport { getRelativePointerPosition, getCurvePoints };\n",null,"export default class Segments<T> {\n  protected segments: T[][];\n\n  public _size: number;\n\n  protected defaultValueCallback: () => T;\n\n  constructor(size: number, defaultValueCallback: () => T) {\n    this.segments = [new Array(size).fill(undefined).map(defaultValueCallback)];\n    this._size = size;\n    this.defaultValueCallback = defaultValueCallback;\n  }\n\n  get size() {\n    return this._size;\n  }\n\n  get numSegments() {\n    return this.segments.length;\n  }\n\n  findSegmentIndex(x: number): {\n    segmentIndex: number;\n    indexInSegment: number;\n  } {\n    let numElements = 0;\n    let segmentIndex = 0;\n    while (\n      segmentIndex < this.segments.length &&\n      numElements + this.segments[segmentIndex].length <= x\n    ) {\n      numElements += this.segments[segmentIndex].length;\n      segmentIndex += 1;\n    }\n    const indexInSegment = x - numElements;\n    return { segmentIndex, indexInSegment };\n  }\n\n  get(x: number, defaultValue: T): T;\n  get(x: number): T | undefined;\n  get(x: number, defaultValue?: T): T | undefined {\n    if (x < 0 || x >= this.size) return defaultValue ?? undefined; // out of range\n    const { segmentIndex, indexInSegment } = this.findSegmentIndex(x);\n    return this.segments[segmentIndex][indexInSegment];\n  }\n\n  set(x: number, ...values: T[]) {\n    if (x < 0 || x >= this.size) return; // out of range\n    let { segmentIndex, indexInSegment } = this.findSegmentIndex(x);\n    for (let i = 0; i < values.length; i += 1) {\n      this.segments[segmentIndex][indexInSegment] = values[i];\n      indexInSegment += 1;\n      if (indexInSegment >= this.segments[segmentIndex].length) {\n        segmentIndex += 1;\n        indexInSegment = 0;\n      }\n      if (segmentIndex > this.segments.length) break;\n    }\n  }\n\n  getSegment(which: number): T[] | undefined {\n    return this.segments[which];\n  }\n\n  getSegmentOf(x: number): { segment: T[]; indexInSegment: number } {\n    const { segmentIndex, indexInSegment } = this.findSegmentIndex(x);\n    return { segment: [...this.segments[segmentIndex]], indexInSegment };\n  }\n\n  getAllSegments() {\n    return this.segments.map((s) => [...s]);\n  }\n\n  /**\n   * Split segments before in front of x.\n   * @param x\n   */\n  splitBefore(x: number): number {\n    if (x < 0 || x >= this.size) return -1; // out of range\n\n    if (x === 0) return 0;\n\n    const { segmentIndex, indexInSegment } = this.findSegmentIndex(x);\n    if (indexInSegment === 0) {\n      // a segment starts at x -> no split necessary\n      return segmentIndex;\n    }\n\n    const segment = this.segments[segmentIndex];\n    const upper = segment.slice(indexInSegment);\n    const lower = segment.slice(0, indexInSegment);\n    this.segments.splice(segmentIndex, 1, lower, upper);\n\n    return segmentIndex + 1;\n  }\n\n  splitAfter(x: number): number {\n    if (x < 0 || x >= this.size) return -1; // out of range\n\n    if (x === this.size - 1) return this.size - 1;\n\n    return this.splitBefore(x + 1) + 1;\n  }\n\n  /** Split segment before and after x.\n   *\n   * @param x The index of the element to put into an isolated segment.\n   */\n  isolate(x: number): number {\n    this.splitAfter(x);\n    return this.splitBefore(x);\n  }\n\n  protected join1(x: number): number {\n    if (x <= 0 || x >= this.size) return -1; // out of range\n\n    const { segmentIndex, indexInSegment } = this.findSegmentIndex(x);\n    if (indexInSegment !== 0) this.joinSegments(segmentIndex);\n\n    return segmentIndex;\n  }\n\n  protected join2(x0: number, x1: number): [number, number] {\n    if (x0 > x1) {\n      const [segmentIndex1, segmentIndex0] = this.join2(x1, x0);\n      return [segmentIndex0, segmentIndex1];\n    }\n\n    if (x1 < 0 || x0 >= this.size) return [-1, -1];\n\n    const clampedX0 = Math.min(this.size - 1, Math.max(x0, 0));\n    const clampedX1 = Math.min(this.size - 1, Math.max(x1, 0));\n\n    const { segmentIndex: segmentIndex0 } = this.findSegmentIndex(clampedX0);\n    const { segmentIndex: segmentIndex1 } = this.findSegmentIndex(clampedX1);\n\n    for (let i = 0; i < segmentIndex1 - segmentIndex0; i += 1) {\n      this.joinSegments(segmentIndex0 + 1);\n    }\n\n    return [x0 < 0 ? -1 : segmentIndex0, x1 >= this.size ? -1 : segmentIndex1];\n  }\n\n  /**\n   * Join segments containing indices x-1 and x.\n   *\n   * @param x The index of the element to join with the element in front of it.\n   */\n  join(x: number): number;\n  /**\n   * Join all segments inbetween x0 and x1 (inclusive).\n   * @param x0 The index of the element in the first element.\n   * @param x1 The index of the element in the second element.\n   */\n  join(x0: number, x1: number): [number, number];\n  join(x0: number, x1?: number): number | [number, number] {\n    return typeof x1 === 'undefined' ? this.join1(x0) : this.join2(x0, x1);\n  }\n\n  /**\n   * Join the segment with the one in front of it.\n   *\n   * @param segmentIndex The index of the segment to join with its predecessor.\n   */\n  joinSegments(segmentIndex: number): number {\n    if (segmentIndex <= 0 || segmentIndex >= this.numSegments) return -1;\n\n    const lower = this.segments[segmentIndex - 1];\n    const upper = this.segments[segmentIndex];\n    this.segments.splice(segmentIndex, 1);\n    lower.push(...upper);\n\n    return segmentIndex - 1;\n  }\n\n  resize(size: number) {\n    if (size > this.size) {\n      const diff = size - this.size;\n      this.segments.push(\n        new Array(diff).fill(0).map(this.defaultValueCallback),\n      );\n      this._size = size;\n    } else if (size > 0 && size < this.size) {\n      this.splitBefore(size);\n      const { segmentIndex } = this.findSegmentIndex(size);\n      this.segments.splice(segmentIndex);\n      this._size = size;\n    }\n  }\n}\n",null],"names":[],"version":3,"file":"index.mjs.map"}